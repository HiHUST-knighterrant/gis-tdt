<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Add a custom style layer</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.css"
      rel="stylesheet"
    />
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script type="module">
      import WindGL from "/one-gis/webgl/wind/MyWind.js";
      let MyWind;
      let map;
      let windData, windImage;
      let windTexture;
      const windFiles = {
        cut: "2016112000_cut",
        0: "2016112000",
        6: "2016112006",
        12: "2016112012",
        18: "2016112018",
        24: "2016112100",
        30: "2016112106",
        36: "2016112112",
        42: "2016112118",
        48: "2016112200",
      };

      mapboxgl.accessToken =
        "pk.eyJ1IjoidGVhbWVuY2FjaGUiLCJhIjoiY2txZzcxa2NrMHB4eTJ1bnphem9lazZrYiJ9.bQ9wCbRR64Iaxgk4-l2JCw";

      function updateWind(name, callback) {
        getJSON(
          "/one-gis/resource/wind/" + windFiles[name] + ".json",
          function (windData) {
            const windImage = new Image();
            windData.image = windImage;
            windImage.src =
              "/one-gis/resource/wind/" + windFiles[name] + ".png";
            windImage.onload = function () {
              callback(windData, windImage);
            };
          }
        );
      }

      function getJSON(url, callback) {
        const xhr = new XMLHttpRequest();
        xhr.responseType = "json";
        xhr.open("get", url, true);
        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            callback(xhr.response);
          } else {
            throw new Error(xhr.statusText);
          }
        };
        xhr.send();
      }

      updateWind("cut", function (data, image) {
        windData = data;
        windImage = image;
        map = new mapboxgl.Map({
          container: "map",
          zoom: 3,
          center: { lat: 36.794095869900445, lng: 102.77435484147946 },
          style: "mapbox://styles/mapbox/light-v10",
          antialias: true, // create the gl context with MSAA antialiasing, so custom layers are antialiased
        });
        map.on("load", () => {
          map.addLayer(highlightLayer, "building");
        });
      });

      function createBuffer(gl, data, bufferType) {
          const buffer = gl.createBuffer();
          gl.bindBuffer(bufferType, buffer);
          gl.bufferData(bufferType, data, gl.STATIC_DRAW);
          return buffer;
      }

      function bindAttribute(gl, buffer, attribute, attribLength, groupLength, start, size) {
          gl.enableVertexAttribArray(attribute);
          gl.vertexAttribPointer(attribute, attribLength, gl.FLOAT, false, groupLength * size, start * size);
      }

      function createTexture(gl, filter, data, width, height) {
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
          if (data instanceof Uint8Array) {
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
          } else {
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
          }
          gl.bindTexture(gl.TEXTURE_2D, null);
          return texture;
      }

      function bindTexture(gl, texture, unit) {
          gl.activeTexture(gl.TEXTURE0 + unit);
          gl.bindTexture(gl.TEXTURE_2D, texture);
      }

      function bindUniform(gl, uniform, value) {
          gl.enableVertexAttribArray(attribute);
          gl.vertexAttribPointer(attribute, attribLength, gl.FLOAT, false, start, groupLength);
      }

      // create a custom style layer to implement the WebGL content
      const highlightLayer = {
        id: "highlight",
        type: "custom",
        onAdd: function (map, gl) {
          /* MyWind = new WindGL(gl);
          MyWind.numParticles = 1024 * 50;
          MyWind.setWind(windData);
          MyWind.image = windImage;
          window.MyWind = MyWind; */

          const vertexSource = area_vertex.textContent;
          const fragmentSource = area_frag.textContent;
          const vertexShader = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vertexShader, vertexSource);
          gl.compileShader(vertexShader);
          const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fragmentShader, fragmentSource);
          gl.compileShader(fragmentShader);
          this.program = gl.createProgram();
          gl.attachShader(this.program, vertexShader);
          gl.attachShader(this.program, fragmentShader);
          gl.linkProgram(this.program);

          windTexture = createTexture(gl, gl.LINEAR, windImage);

          this.a_pos = gl.getAttribLocation(this.program, "a_pos");
          this.a_uv = gl.getAttribLocation(this.program, "a_uv");
          this.u_sampler2D = gl.getUniformLocation(this.program, "u_sampler2D");
          this.u_mvpMatrix = gl.getUniformLocation(this.program, "u_mvpMatrix");
          const toyko = mapboxgl.MercatorCoordinate.fromLngLat({
            lng: 73,
            lat: 18,
          });
          const kyiv = mapboxgl.MercatorCoordinate.fromLngLat({
            lng: 136,
            lat: 18,
          });
          const helsinki = mapboxgl.MercatorCoordinate.fromLngLat({
            lng: 73,
            lat: 54,
          });
          const berlin = mapboxgl.MercatorCoordinate.fromLngLat({
            lng: 136,
            lat: 54,
          });

          let vertexData = new Float32Array([
              toyko.x, toyko.y,0,0,0,
              kyiv.x, kyiv.y,0,1,0,
              helsinki.x, helsinki.y,0,0,1,
              berlin.x, berlin.y,0,1,1,
          ]);
          let indexData = new Int8Array([
            0,1,2,
            2,1,3,
          ]);
          this.indexData = indexData;
          this.vertexSize = 5;
          this.byteSize = vertexData.BYTES_PER_ELEMENT;
          this.vertexBuffer = createBuffer(gl, vertexData, gl.ARRAY_BUFFER);
          this.indexBuffer = createBuffer(gl, indexData, gl.ELEMENT_ARRAY_BUFFER);

        },

        render: function (gl, mvpMatrix) {
          // MyWind.draw();
          gl.useProgram(this.program);
          
          gl.uniformMatrix4fv(this.u_mvpMatrix, false, mvpMatrix);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
          bindAttribute(gl, this.vertexBuffer, this.a_pos, 3, 5, 0, this.byteSize);
          bindAttribute(gl, this.vertexBuffer, this.a_uv, 2, 5, 3, this.byteSize);
          bindTexture(gl, windTexture, 0);
          gl.drawElements(gl.TRIANGLES, this.indexData.length, gl.UNSIGNED_BYTE, 0);
          
          map.triggerRepaint();
        },
      };
    </script>
    <!-- 平面顶点着色器 -->
    <scirpt id="area_vertex" type="x-shader/x-vertex">
      precision highp float; 
      attribute vec2 a_pos;
      attribute vec2 a_uv;
      <!-- 
      //uniform mat4 u_model; 
      //uniform mat4 u_view; 
      //uniform mat4 u_project; -->
      uniform mat4 u_mvpMatrix; 
      varying vec2 v_uv; 
      void main(){ 
        <!-- //gl_Position = u_project * u_view * u_model * vec4(a_pos, 1.0);  -->
        v_uv = a_uv;
        gl_Position = u_mvpMatrix * vec4(a_pos, 0.0, 1.0); }
    </scirpt>
    <!-- 平面片元着色器 -->
    <scirpt id="area_frag" type="x-shader/x-fargment">
      precision highp float; 
      varying vec2 v_uv; 
      uniform sampler2D u_sampler2D;
      void main(){ 
        gl_FragColor = texture2D(u_sampler2D, v_uv);
      }
    </scirpt>
  </body>
</html>
